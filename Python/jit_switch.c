// This file is generated by Tools/cases_generator/jit_switch_generator.py
// from:
//   Python/bytecodes.c, Python/supernodes.c
// Do not edit!

#ifndef Py_SWITCH_JIT_H
#define Py_SWITCH_JIT_H

#include "Python.h"
#include "pycore_uop_ids.h"
#include "opcode_ids.h"
#include "jit_switch.h"



#ifdef __cplusplus
extern "C" {
#endif


#ifdef _Py_JIT


// This function always needs to be fed 2 uops
SuperNode
_JIT_INDEX(const _PyUOpInstruction *uops, uint16_t start_index) {
    switch (uops[start_index + 0].opcode) {
        case _COPY:
            switch (uops[start_index + 1].opcode) {
                case _TO_BOOL_BOOL:
                    return (SuperNode) {.index = _COPY_PLUS__TO_BOOL_BOOL, .length = 2};
                    break;
                default:
                    return (SuperNode) {.index = uops[start_index].opcode, .length = 1};
            }
            break;
        case _LOAD_FAST_0:
            switch (uops[start_index + 1].opcode) {
                case _GUARD_TYPE_VERSION:
                    return (SuperNode) {.index = _LOAD_FAST_0_PLUS__GUARD_TYPE_VERSION, .length = 2};
                    break;
                default:
                    return (SuperNode) {.index = uops[start_index].opcode, .length = 1};
            }
            break;
        case _GUARD_NOS_INT:
            switch (uops[start_index + 1].opcode) {
                case _BINARY_OP_ADD_INT:
                    return (SuperNode) {.index = _GUARD_NOS_INT_PLUS__BINARY_OP_ADD_INT, .length = 2};
                    break;
                default:
                    return (SuperNode) {.index = uops[start_index].opcode, .length = 1};
            }
            break;
        default:
            return (SuperNode) {.index = uops[start_index].opcode, .length = 1};
    }
}

#endif  // _Py_JIT

#ifdef __cplusplus
}
#endif

#endif // Py_SWITCH_JIT_H
# 